import argparse
import math

import matplotlib.pyplot as plt
import torch
from utils import get_one_hot_labels, get_input_dimensions, get_noise, combine_vectors, show_tensor_images
from utils import z_dim, mnist_shape, num_classes, device
from model import *


n_interpolation = 9  # Choose the interpolation: how many intermediate images you want + 2 (for the start and end image)

generator_input_dim, discriminator_im_chan = get_input_dimensions(z_dim, mnist_shape, num_classes)

#  Load Generator
gen = Generator(input_dim=generator_input_dim).to(device)
checkpoint = torch.load("/content/gen.pt", weights_only=True)
gen.load_state_dict(checkpoint['model_state_dict'])

start_plot_number = 1  # Choose the start digit
end_plot_number = 5  # Choose the end digit
num_images = 9


def interpolate_class(first_number, second_number, n_interpolation, interpolation_noise):
    first_label = get_one_hot_labels(torch.Tensor([first_number]).long(), num_classes)
    second_label = get_one_hot_labels(torch.Tensor([second_number]).long(), num_classes)

    # Calculate the interpolation vector between the two labels
    percent_second_label = torch.linspace(0, 1, n_interpolation)[:, None]
    interpolation_labels = first_label * (1 - percent_second_label) + second_label * percent_second_label

    # Combine the noise and the labels
    noise_and_labels = combine_vectors(interpolation_noise, interpolation_labels.to(device))
    fake = generate_image(noise_and_labels)  # fake = gen(noise_and_labels)
    show_tensor_images(fake, num_images=n_interpolation, nrow=int(math.sqrt(n_interpolation)), show=True)


def generate_image(noise_and_labels):
    gen.eval()
    return gen(noise_and_labels)


# plt.figure(figsize=(8, 8))
# interpolation_noise = get_noise(1, z_dim, device=device).repeat(n_interpolation, 1)
# interpolate_class(start_plot_number, end_plot_number, gen, n_interpolation, interpolation_noise)
# _ = plt.axis('off')

"""
Uncomment the following lines of code if you would like to visualize a set of pairwise class
interpolations for a collection of different numbers, all in a single grid of interpolations.
You'll also see another visualization like this in the next code block!
"""

# plot_numbers = [2, 3, 4, 5, 7]
# n_numbers = len(plot_numbers)
# plt.figure(figsize=(8, 8))
# for i, first_plot_number in enumerate(plot_numbers):
#     for j, second_plot_number in enumerate(plot_numbers):
#         plt.subplot(n_numbers, n_numbers, i * n_numbers + j + 1)
#         interpolate_class(first_plot_number, second_plot_number)
#         plt.axis('off')
# plt.subplots_adjust(top=1, bottom=0, left=0, right=1, hspace=0.1, wspace=0)
# plt.show()
# plt.close()

# Command-line interface using argparse
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Generate or interpolate images using the GAN model.")
    parser.add_argument('--class_id', type=int, required=True, help="Class label (0-9) for generating a single image.")
    parser.add_argument('--class2_id', type=int,
                        help="Second class label (0-9) for interpolation (only used if --interpolate is set).")
    parser.add_argument('--interpolate', action='store_true', help="Flag to enable interpolation between two classes.")
    parser.add_argument('--num_interpolations', type=int, help="Number of interpolations between the two images")
    parser.add_argument('--num_images', type=int, help="Number of fake images to be generated by generator")
    args = parser.parse_args()

    if args.interpolate:
        # Ensure the second class is provided if interpolation is enabled
        if args.class2_id is None:
            raise ValueError("You must specify a second class with --class2 when using --interpolate.")

        n_interpolation = args.num_interpolations if args.num_interpolations is not None else n_interpolation

        # Interpolate between two class labels
        interpolation_noise = get_noise(1, z_dim, device=device).repeat(n_interpolation, 1)  # generate interpolation noise
        interpolate_class(args.class_id, args.class2, n_interpolation, interpolation_noise)

    else:
        # Generate an image for a single class
        num_images = args.num_images if args.num_images is not None else num_images
        fake_noise = get_noise(num_images, z_dim, device)
        one_hot_labels = get_one_hot_labels(args.class_id, num_classes)
        noise_and_labels = combine_vectors(fake_noise, one_hot_labels)
        generated_image = generate_image(noise_and_labels)

        show_tensor_images(generated_image, num_images=num_images, nrow=int(math.sqrt(num_images)), show=True)

        # display_image(generated_image)

    # Generate the image for the specified class

    # Display the generated image
    # display_image(generated_image)
